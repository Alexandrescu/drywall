module.exports = function(io, mongoose, app) {
  var clients = app.basket;

  io.sockets.on('connection', function (socket) {
	  socket.emit('requestData');

    socket.on('setData', function(data) {
      clients[socket.id] = data;

      for(entry in clients) {
        console.log(entry + " has token " + clients[entry].token + " and lectureId " + clients[entry].lectureId);  
      }
      
    });

    socket.on('addQuestion', function(data) {
      if(clients[socket.id] && data.hasOwnProperty("content") && data.hasOwnProperty("slideNumber") ) {
        var client = clients[socket.id];

        if(!client.hasOwnProperty("token") && !client.hasOwnProperty("lectureId") ) return;

        app.db.models.User.findOne({token: client.token}, function(err, user) {
          /* User is valid */
          app.db.models.Lecture.findOne({ _id: client.lectureId}, function(err, lecture) {
            
            if(err) return;
            if(lecture) {
              /* Lecture if valid */
              console.log(lecture);
              var fieldsToSet = {
                content: data.content,
                slideNumber: data.slideNumber,
                whoAsked: user._id,
                votes: 0
              };

              app.db.models.Question.create(fieldsToSet, function(err, question){
                if(err) return;
                lecture.questions.push(question._id);
                lecture.save();
              });
            }
          });
        });
      }
    });

    socket.on('addVote', function(data) {
      if(clients[socket.id] && data.hasOwnProperty("questionId")) {
        var client = clients[socket.id];

        if(!client.hasOwnProperty("token") && !client.hasOwnProperty("lectureId") ) return;

        app.db.models.User.findOne({token: client.token}, function(err, user) {
          /* User is valid */

          app.db.models.Question.findById(data.questionId, function(err, question) {
            console.log('founded');
            if(err) return;

            if(question && question.whoVoted.indexOf(user._id) == -1) {
              console.log('voting');
              question.votes++;
              question.whoVoted.push(user._id);
              question.save();
            }
            else console.log("Already exists");
          });
        });
      }
    });

    socket.on('addAnswer', function(data){
      if(clients[socket.id] && data.hasOwnProperty("questionId") && data.hasOwnProperty("answer")) {
        var client = clients[socket.id];

        if(!client.hasOwnProperty("token") && !client.hasOwnProperty("lectureId") ) return;

        app.db.models.User.findOne({token: client.token}, function(err, user) {
          if(user)
            // Valid user
            app.db.models.Course.findOne({lectures: client.lectureId}, function(err, course) {
              if(course && course.creator.equals(user._id)) {
                // He has permission to answer on this lecture
                app.db.models.Lecture.findOne({questions: data.questionId}, function(err, lecture) {
                  if(lecture)
                    //This question is part of this lecture
                    app.db.models.Question.findOneAndUpdate({_id:data.questionId}, {$set : {answer: data.answer}}, {safe: true, upsert: true}, function(err, question){
                      if(err) return;
                    });
                });
              }
            });
        });
      }
    });

		socket.emit('news', {hello : 'hi'});
	
		//Debug purposes
		socket.on('pulse', function(data) {
      socket.emit('news', {hello : data.message});
    });

    socket.on('disconnect', function() {
      delete clients[socket.id];
    });
		
	});
};
